Программе на стандартном потоке ввода задаются следующие параметры дискретной случайной величины.

Количество различных значений (n), которые принимает случайная величина (0 < n <= 100).
n пар целых чисел, первое из которых задает значение, принимаемое случайной величиной (32-битное знаковое целое число), а второе – вероятность данного значения в процентах.
Количество чисел (m), которое необходимо сгенерировать (0 <= m < 1000).
Затравка для ГПСЧ (seed).
С использованием алгоритма генерации случайных чисел с заданным распределением из равномерно распределенных случайных чисел, описанного ниже, сгенерируйте и напечатайте на стандартный поток вывода указанное число случайных чисел.

Так как вероятности выпадения значений задаются в процентах, то сначала необходимо сгенерировать случайную величину в интервале [0; 100). Интервал [0; 100) разбивается на подинтервалы, соответствующие процентной вероятности выпадения заданного значения случайной величины, в порядке их описания во входном файле. Например, если случайная величина принимает 3 значения с вероятностями 20%, 30% и 50%, то интервал [0;100) разбивается на подинтервалы [0; 20), [20; 50), [50; 100). В зависимости от того, в какой подинтервал попало равномерно распределенное случайное число, берется соответствующее значение требуемой случайной величины.

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

enum { N = 100 };

typedef struct Node
{
    int nmb;
    int psb;
} Rnd;

int
main(int argc, char** argv)
{
    int n;
    scanf ("%d", &n);
    Rnd *arr = (Rnd*)calloc(n, sizeof(Rnd));
    for (int i = 0; i < n; ++ i) {
        scanf ("%d%d", &arr[i].nmb, &arr[i].psb);
    }
    int m;
    scanf ("%d", &m);
    int seed;
    scanf ("%d", &seed);
    srand(seed);
    for (int i = 0; i < m; ++i) {
        int numb = rand()/(RAND_MAX + 1.0) * N;
        int t = 0;
        for (int j = 0; j < n; ++j) {
            t += arr[j].psb;
            if (t > numb) {
                printf ("%d\n", arr[j].nmb);
                break;
            }
        }
    }
    free(arr);
    return 0;
}
