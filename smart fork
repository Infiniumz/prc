#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>

int
main(int argc, char **argv)
{
    setbuf(stdin, NULL);
    int scan2, num;
    int status;
    int scan = 0;
    do {
        pid_t p = fork();
        if (!p) {
            scan2 = scanf("%d", &num);
        } else if (p > 0) {
            wait(&status);
            if (!WIFEXITED(status) || WEXITSTATUS(status)) {
                if (!scan) {
                    printf("-1");
                    fflush(stdout);
                    _exit(0);
                }
                _exit(1);
            }
            if (scan) {
                printf ("%d\n", num);
                fflush(stdout);
            }
            _exit(0);
        } else {
            _exit(1);
        }
        ++scan;
    } while (scan2 == 1);
    _exit(0);
}
На стандартном потоке ввода задается последовательность целых чисел типа int, завершающаяся признаком конца файла. Для каждого введенного числа должен создаваться отдельный процесс, который выводит его же на стандартный поток вывода, но так, что в итоге последовательность чисел на стандартном потоке вывода окажется идущей в обратном порядке относительно чисел на стандартном потоке ввода. Дополнительный процесс может фикисировать признак конца ввода на стандартном потоке ввода.

Каждый процесс отвечает за чтение, хранение и вывод только одного числа из всей последовательности.

Например, если на стандартном потоке ввода задана последовательность 1 2 3, то в дополнение к родителю должно быть создано три процесса и на стандартный поток вывода должно быть выведено:

3
2
1
Если невозможно создать столько процессов, сколько чисел во входной последовательности, то вместо всей входной последовательности на стандартный поток вывода должно быть выведено число -1.

Стандартный поток ввода не является файлом произвольного доступа (является каналом).

Процесс-родитель должен завершаться самым последним из всех процессов. Этот процесс должен завершаться с кодом завершения 0 в любом случае.
